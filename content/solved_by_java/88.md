---
title: "88 丢棋子问题"
layout: page
date: 2019-12-06 13:59
---

[TOC]

# ac

```java
记问题为P(n, k)，在最差的情况下扔的最小次数

n == 0, 不用管
k == 1, 必须从第1层尝试到第n层

假设棋子从i层扔
1. 碎了(少了一个棋子)， P(n, k) 变成 P(n-i, k-1)
2. 没有碎, P(n, k) 变成 P(i-1, k)

即有, 从i层扔下
1 + Max( P(n-i, k-1), P(i-1, k) )

i, n-i 确保范围是[1, n], 最后
P(n, k) = 1 + Min (  Max( P(n-i, k-1), P(i-1, k) ) )
```

* 常规动态规划

* 空间 `n * k`
* 时间 `n * k * n`

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;

public class Main {
    public static Scanner sc = new Scanner(System.in);

    public static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

    public static void main(String[] args) throws Exception {
        int n = sc.nextInt();
        int kChess = sc.nextInt();

        int[][] dp = new int[n+1][kChess+1];
        for(int i=0;i<=kChess;i++){
            dp[0][i] = 0;
        }
        // 只有一层
        for(int i=0;i<=kChess;i++){
            dp[1][i] = 1;
        }
        // 只有1个棋子
        for(int i=1;i<=n;i++){
            dp[i][1] = i;
        }
        // 2～n层
        for(int i=2;i<=n;i++){
            // 2～kChess个棋子
            for(int j=2;j<=kChess;j++){
                int minVal = Integer.MAX_VALUE;
                for(int k=1;k<=i;k++){
                    int tmp = Math.max(dp[i-k][j-1], dp[k-1][j]);
                    minVal = Math.min(minVal, tmp);
                }
                dp[i][j] = minVal + 1;
            }
        }
        System.out.println(dp[n][kChess]);
    }

}
/*
P(n, k) = 1 + Min (  Max( P(n-i, k-1), P(i-1, k) ) )

3 2
2

p\k
   1  2
0  0  0
1  1  1
2  1
3  1
 */
```

* 四边形不等式(TODO)
